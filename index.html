<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vocabulary Quiz 1451â€“1600 (ì˜¤ë‹µ ì–´ì›/ì˜ë¯¸ ìƒì„± í•´ì„¤ ê°•í™” + ë°œìŒ + ìŠ¤ì½”ì–´ë³´ë“œ)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
    body { margin: 0; background: #0b0c10; color: #e7e7e7; font-size: 18px; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .card { background: #14161d; border: 1px solid #232636; border-radius: 14px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .sub { opacity: .85; font-size: 15px; margin-bottom: 14px; line-height: 1.55; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .pill { background:#1c2030; border:1px solid #2b3250; padding: 8px 12px; border-radius: 999px; font-size: 14px; }
    .btn { background:#2a63ff; border:0; color:white; padding:12px 14px; border-radius: 12px; cursor:pointer; font-weight:900; font-size: 15px; }
    .btn.secondary { background:#2b3250; }
    .btn.danger { background:#ff3b3b; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .progressbar { height: 12px; background:#0f1118; border:1px solid #232636; border-radius:999px; overflow:hidden; margin-top: 12px; }
    .bar { height:100%; width:0%; background:#2a63ff; }
    .qbox { margin-top: 14px; }
    .qhead { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .qnum { font-weight:900; font-size: 16px; opacity:.95; }
    .word { font-size: 36px; font-weight:1000; letter-spacing:.3px; }
    .meta { font-size: 13px; opacity:.85; }
    .choices { display:grid; gap:12px; margin-top: 14px; }
    .choice {
      background:#0f1118; border:1px solid #2b3250; border-radius: 14px;
      padding: 14px; cursor:pointer; display:flex; gap:12px; align-items:flex-start;
      transition: transform .05s ease;
      user-select:none;
      font-size: 18px;
      line-height: 1.5;
    }
    .choice:hover { transform: translateY(-1px); }
    .choice.selected { border-color:#86a3ff; background:#121a34; }
    .choice.correct { border-color:#35d07f; background:#0f1f18; }
    .choice.wrong { border-color:#ff6b6b; background:#231012; }
    .tag { font-weight:1000; width: 30px; text-align:center; opacity:.95; }
    .result { margin-top: 12px; padding: 14px; border-radius: 14px; border:1px solid #2b3250; background:#0f1118; }
    .result.good { border-color:#35d07f; background:#0f1f18; }
    .result.bad { border-color:#ff6b6b; background:#231012; }
    .small { font-size: 15px; opacity:.95; line-height:1.6; }
    .footer { margin-top: 14px; display:flex; gap:10px; flex-wrap:wrap; }
    details { margin-top: 14px; }
    summary { cursor:pointer; font-weight:1000; font-size: 16px; }
    table { width:100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom:1px solid #232636; padding: 12px 8px; text-align:left; font-size: 15px; }
    th { opacity:.9; }
    .muted { opacity:.75; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 10px; }
    select, input[type="checkbox"] { accent-color: #2a63ff; }
    select {
      background:#0f1118; color:#e7e7e7; border:1px solid #2b3250;
      border-radius: 12px; padding: 10px 12px; font-weight:900; font-size: 15px;
    }
    label { font-size: 15px; opacity:.95; display:flex; gap:8px; align-items:center; }
    .hr { border:0; border-top:1px solid #232636; margin:16px 0; }
    .etymo {
      margin-top: 10px;
      padding: 14px;
      border: 1px dashed #2b3250;
      border-radius: 14px;
      background: rgba(30,34,52,.35);
    }
    .etymo .title { font-weight:1000; margin-bottom: 8px; font-size: 16px; }
    .etymo ul { margin: 10px 0 0; padding-left: 20px; }
    .etymo li { margin: 8px 0; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; padding: 3px 8px; border:1px solid #2b3250; border-radius: 10px; background:#0f1118; }
    .mini { font-size: 13px; opacity:.85; }
    .iconbtn {
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #2b3250;
      background: #0f1118;
      color: #e7e7e7;
      cursor: pointer;
      font-weight: 1000;
      font-size: 15px;
    }
    .iconbtn:hover { border-color:#86a3ff; background:#121a34; }
    .scoreboard {
      margin-top: 14px;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid #232636;
      background: #0f1118;
    }
    .scoregrid {
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .scoreitem {
      background:#14161d;
      border:1px solid #2b3250;
      border-radius: 14px;
      padding: 12px;
    }
    .scorelabel { font-size: 13px; opacity:.75; font-weight:900; }
    .scorevalue { font-size: 24px; font-weight:1000; margin-top: 4px; }
    @media (min-width: 760px) {
      .scoregrid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row">
        <div>
          <h1>Vocabulary Quiz (1451â€“1600) â€” ë°œìŒ(ë¯¸êµ­ì‹) + ìŠ¤ì½”ì–´ë³´ë“œ + ì˜¤ë‹µ í•´ì„¤</h1>
          <div class="sub">
            - ë³´ê¸°(ë‹µì•ˆ)ë¥¼ ëˆ„ë¥´ë©´ <b>ì¦‰ì‹œ ì±„ì </b>ë©ë‹ˆë‹¤.<br/>
            - ë¬¸í•­ì´ ëœ¨ë©´ <b>ë¯¸êµ­ì‹ ë°œìŒ</b>ì„ ìë™ ì¬ìƒ(ê°€ëŠ¥í•œ ê²½ìš°)í•˜ê³ , ğŸ”Š ë²„íŠ¼ìœ¼ë¡œ <b>ë°˜ë³µ ì²­ì·¨</b>í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br/>
            - ì˜¤ë‹µì¼ ë•Œë§Œ â€œì™œ ê·¸ ëœ»ì´ ë˜ëŠ”ì§€(ì–´ì›/ì˜ë¯¸ ìƒì„±/ì•”ê¸°/ì˜¤ë‹µ ë°©ì§€)â€ë¥¼ ë‹¨ì–´ë³„ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.
          </div>
        </div>
        <div class="row">
          <div class="pill" id="pillCount">ë¬¸í•­: 0</div>
          <div class="pill" id="pillProgress">ì§„í–‰: 0/0</div>
          <div class="pill" id="pillScore">ì ìˆ˜: 0</div>
        </div>
      </div>

      <div class="controls">
        <label>ë²”ìœ„
          <select id="rangeSelect">
            <option value="1451-1600" selected>1451â€“1600 (ì „ì²´)</option>
            <option value="1451-1469">1451â€“1469</option>
            <option value="1470-1489">1470â€“1489</option>
            <option value="1490-1509">1490â€“1509</option>
            <option value="1510-1529">1510â€“1529</option>
            <option value="1530-1549">1530â€“1549</option>
            <option value="1550-1569">1550â€“1569</option>
            <option value="1570-1586">1570â€“1586</option>
            <option value="1587-1600">1587â€“1600</option>
          </select>
        </label>

        <label><input type="checkbox" id="shuffleToggle" checked /> ë¬¸ì œ ìˆœì„œ ì„ê¸°</label>
        <label><input type="checkbox" id="saveToggle" checked /> ì§„í–‰ìƒí™© ìë™ ì €ì¥</label>
        <label><input type="checkbox" id="autoPronounceToggle" checked /> ë¬¸ì œ í‘œì‹œ ì‹œ ìë™ ë°œìŒ</label>

        <button class="btn" id="btnStart">í€´ì¦ˆ ì‹œì‘/ì¬ì‹œì‘</button>
        <button class="btn secondary" id="btnWrongOnly" disabled>ì˜¤ë‹µë§Œ ë‹¤ì‹œ</button>
        <button class="btn danger" id="btnReset">ì™„ì „ ì´ˆê¸°í™”</button>
      </div>

      <div class="progressbar" aria-label="progress">
        <div class="bar" id="bar"></div>
      </div>

      <div class="scoreboard" id="scoreboard">
        <div style="font-weight:1000; font-size:16px;">ìŠ¤ì½”ì–´ë³´ë“œ</div>
        <div class="mini muted">ì´ ì‘ì‹œ/ì •ë‹µ/ì˜¤ë‹µ, ì—°ì† ì •ë‹µ(ìŠ¤íŠ¸ë¦­)ì„ ì‹¤ì‹œê°„ í‘œì‹œí•©ë‹ˆë‹¤.</div>
        <div class="scoregrid">
          <div class="scoreitem">
            <div class="scorelabel">ì‘ì‹œ(ì±„ì  ì™„ë£Œ)</div>
            <div class="scorevalue" id="sbAnswered">0</div>
          </div>
          <div class="scoreitem">
            <div class="scorelabel">ì •ë‹µ</div>
            <div class="scorevalue" id="sbCorrect">0</div>
          </div>
          <div class="scoreitem">
            <div class="scorelabel">ì˜¤ë‹µ</div>
            <div class="scorevalue" id="sbWrong">0</div>
          </div>
          <div class="scoreitem">
            <div class="scorelabel">ì—°ì† ì •ë‹µ</div>
            <div class="scorevalue" id="sbStreak">0</div>
          </div>
        </div>
        <div class="mini muted" id="sbNote" style="margin-top:8px;"></div>
      </div>

      <div class="qbox" id="qbox"></div>

      <div class="footer">
        <button class="btn secondary" id="btnPrev">ì´ì „</button>
        <button class="btn" id="btnNext">ë‹¤ìŒ</button>
      </div>

      <div id="summary"></div>
    </div>
  </div>

<script>
/** =========================
 *  0) ë°œìŒ(ë¯¸êµ­ì‹) - Web Speech API
 *  ========================= */
let userInteracted = false;
let lastSpokenKey = "";

function pickUSVoice() {
  const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
  let v = voices.find(x => (x.lang || "").toLowerCase() === "en-us");
  if (v) return v;
  v = voices.find(x => (x.lang || "").toLowerCase().includes("en-us"));
  if (v) return v;
  v = voices.find(x => (x.lang || "").toLowerCase().startsWith("en"));
  return v || null;
}

function speakWord(word, {force=false} = {}) {
  if (!("speechSynthesis" in window) || !word) return;
  try {
    const key = `${word}`;
    if (!force && key === lastSpokenKey) return;

    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(word);
    u.lang = "en-US";
    const v = pickUSVoice();
    if (v) u.voice = v;
    u.rate = 0.95;
    u.pitch = 1.0;
    u.volume = 1.0;

    lastSpokenKey = key;
    window.speechSynthesis.speak(u);
  } catch {}
}

if ("speechSynthesis" in window) {
  window.speechSynthesis.onvoiceschanged = () => {};
}

/** =========================
 *  1) ì›ë¬¸ ë°ì´í„° (1451â€“1600)
 *  ========================= */
const RAW = String.raw`
1451 / impartial / ê³µì •í•œ, í¸ê²¬ì´ ì—†ëŠ”
1452 / confederate / ê³µë²”, ê³µëª¨ì
1453 / legislation / ë²•ë¥ (ì œì •)
1454 / inscription / ìƒˆê¸°ê¸°, ëª…ê°
1455 / versatile / ë‹¤ì¬ë‹¤ëŠ¥í•œ, ë‹¤ìš©ë„ì˜
1456 / limp / ê¸°ìš´ì´ ì—†ëŠ”, ì¶• ì²˜ì§„
1457 / intrinsic / ê³ ìœ í•œ, ë³¸ì§ˆì ì¸
1458 / limb / íŒ”, ë‹¤ë¦¬, (ìƒˆì˜) ë‚ ê°œ
1459 / prehistoric / ì„ ì‚¬ ì‹œëŒ€ì˜
1460 / rush / ì„œë‘ë¥´ë‹¤
1461 / stale / ì§„ë¶€í•œ, ì‹ ì„ í•˜ì§€ ì•Šì€
1462 / gratitude / ê°ì‚¬, ê³ ë§ˆì›€
1463 / garment / ì˜ë³µ, ì˜·
1464 / reproach / ë¹„ë‚œí•˜ë‹¤, ë‚˜ë¬´ë¼ë‹¤
1465 / handicap / ë¶ˆë¦¬í•˜ê²Œ ë§Œë“¤ë‹¤, ë°©í•´í•˜ë‹¤
1466 / spiny / ê°€ì‹œê°€ ë§ì€
1467 / suspicion / ì˜ì‹¬, ë¶ˆì‹ , í˜ì˜
1468 / spawn / (ì•Œì„) ë‚³ë‹¤, ìƒì‚°í•˜ë‹¤
1469 / sedentary / í•œê³³ì— ë¨¸ë¬¼ëŸ¬ ì‚¬ëŠ”, ì •ì°©í•˜ê³  ìˆëŠ”
1470 / humble / ê²¸ì†í•œ
1471 / incur / (ë‚˜ìœ ìƒí™©ì„) ì´ˆë˜í•˜ë‹¤, (ì†í•´Â·ë¹šì„) ë°œìƒì‹œí‚¤ë‹¤
1472 / indulge / (ìš•êµ¬Â·ì¾Œë½ì—) ë¹ ì§€ë‹¤, íƒë‹‰í•˜ë‹¤
1473 / thaw / ë…¹ë‹¤, í•´ë™ì‹œí‚¤ë‹¤
1474 / inspection / ì‚¬ì°°, ì ê²€, ì •ë°€ì¡°ì‚¬
1475 / invert / ë’¤ì§‘ë‹¤, ë„ì¹˜ì‹œí‚¤ë‹¤
1476 / leftover / (ì£¼ë¡œ ë³µìˆ˜ë¡œ) ë‚¨ì€ ìŒì‹
1477 / liken / ~ì— ë¹„ìœ í•˜ë‹¤
1478 / disseminate / (ì •ë³´Â·ì‚¬ìƒ ë“±ì„) í¼ëœ¨ë¦¬ë‹¤, ì „íŒŒí•˜ë‹¤
1479 / linger / ë‚¨ì•„ ìˆë‹¤, ì˜¤ë˜ ëŒë‹¤
1480 / circumstance / ìƒí™©, í™˜ê²½
1481 / martial / ì‹¸ì›€ì˜, ì „ìŸì˜
1482 / sorrowful / ìŠ¬í”ˆ
1483 / peninsula / ë°˜ë„
1484 / monk / ìˆ˜ë„ì, ìˆ˜ë„ìŠ¹
1485 / maternal / ì–´ë¨¸ë‹ˆì˜, ëª¨ì„±ì˜
1486 / minister / ì„±ì§ì, ëª©ì‚¬
1487 / monetary / í†µí™”[í™”í]ì˜, ê¸ˆì „ì˜
1488 / nostalgia / í–¥ìˆ˜(ë³‘)
1489 / oblige / ì˜ë¬´ì ìœ¼ë¡œ ~í•˜ê²Œ í•˜ë‹¤, ê°•ìš”í•˜ë‹¤
1490 / vocational / ì§ì—…ê³¼ ê´€ë ¨ëœ, ì§ë¬´ìƒì˜
1491 / contestant / (ëŒ€íšŒÂ·ì‹œí•©ì˜) ì°¸ê°€ì
1492 / subside / ê°€ë¼ì•‰ë‹¤, ì§„ì •ë˜ë‹¤
1493 / stiffen / ë»£ë»£í•´ì§€ë‹¤, ê²½ì§ë˜ë‹¤
1494 / onward / ì•ìœ¼ë¡œ, ë‚˜ì•„ê°€ì„œ
1495 / outlaw / ë¶ˆë²•í™”í•˜ë‹¤, ê¸ˆí•˜ë‹¤
1496 / outset / ì°©ìˆ˜, ì‹œì´ˆ, ë°œë‹¨
1497 / overturn / ë’¤ì§‘(íˆ)ë‹¤
1498 / ramification / íŒŒë¬¸, ì˜í–¥
1499 / pathway / ì¢ì€ ê¸¸, í†µë¡œ
1500 / pierce / ëš«ë‹¤, ê´€í†µí•˜ë‹¤
1501 / nutrient / ì˜ì–‘ì†Œ, ì˜ì–‘ë¶„
1502 / lodge / ì˜¤ë‘ë§‰, ì‚°ì¥
1503 / loom / ì–´ë ´í’‹ì´ ë‚˜íƒ€ë‚˜ë‹¤, ê³§ ë‹¥ì¹  ê²ƒì²˜ëŸ¼ ë³´ì´ë‹¤
1504 / mainstream / (ì‚¬ìƒ ë“±ì˜) ì£¼ë¥˜, ëŒ€ì„¸
1505 / manuscript / (ì±…Â·ì•…ë³´ ë“±ì˜) ì›ê³ , ì‚¬ë³¸
1506 / erupt / (í™”ì‚°ì´) ë¶„ì¶œí•˜ë‹¤, í­ë°œí•˜ë‹¤
1507 / mighty / ê°•ë ¥í•œ, í˜ì„¼
1508 / hull / ì„ ì²´
1509 / muddy / ì§„í™íˆ¬ì„±ì´ì¸
1510 / nuisance / ì„±ê°€ì‹  ì‚¬ëŒ[ì¼], ê³¨ì¹«ê±°ë¦¬
1511 / splendid / í›Œë¥­í•œ, ë©‹ì§„
1512 / strife / ê°ˆë“±, ë¶ˆí™”, ë‹¤íˆ¼
1513 / stature / ìœ„ìƒ, ìˆ˜ì¤€
1514 / adversity / ì—­ê²½, ê³ ë‚œ
1515 / spacious / ë„“ì€
1516 / unconsciously / ë¬´ì˜ì‹ì ìœ¼ë¡œ
1517 / authoritative / ê¶Œìœ„ ìˆëŠ”
1518 / actualize / í˜„ì‹¤ë¡œ ë§Œë“¤ë‹¤, ì‹¤í˜„í•˜ë‹¤
1519 / console / ìœ„ë¡œí•˜ë‹¤
1520 / drag / ëŒë‹¤, ëŒê³  ê°€ë‹¤
1521 / authentic / ì§„ì •í•œ, ì§„ì§œì˜
1522 / mammal / í¬ìœ ë™ë¬¼
1523 / plunge / ëŒì…í•˜ë‹¤
1524 / gigantic / ê±°ëŒ€í•œ
1525 / predominate / ìš°ì„¸í•˜ë‹¤, ì§€ë°°í•˜ë‹¤
1526 / rust / ë…¹ì´ ìŠ¬ë‹¤, ë¶€ì‹í•˜ë‹¤[ì‹œí‚¤ë‹¤]
1527 / recede / ë¬¼ëŸ¬ë‚˜ë‹¤, ì•½í•´ì§€ë‹¤
1528 / reprimand / ì§ˆì±…í•˜ë‹¤
1529 / rhetorical / ìˆ˜ì‚¬ì ì¸, ì›…ë³€ì ì¸
1530 / riddle / êµ¬ë©ì„ ìˆ­ìˆ­ ëš«ë‹¤, ë²Œì§‘ê°™ì´ ë§Œë“¤ë‹¤
1531 / generalization / ì¼ë°˜í™”
1532 / scramble / ê¸°ì–´ ì˜¤ë¥´ë‹¤
1533 / speculate / ì¶”ì¸¡[ì§ì‘]í•˜ë‹¤
1534 / stalk / (ì‹ë¬¼ì˜) ì¤„ê¸°
1535 / stroll / ì‚°ì±…í•˜ë‹¤, ê±°ë‹ë‹¤
1536 / stumble / ìš°ì—°íˆ ë°œê²¬í•˜ë‹¤
1537 / outrun / ë” ë¹¨ë¦¬[ë©€ë¦¬] ë‹¬ë¦¬ë‹¤
1538 / squeeze / ì§œë‹¤
1539 / dumb / ë©ì²­í•œ
1540 / stifle / ì–µëˆ„ë¥´ë‹¤, ì–µì••í•˜ë‹¤
1541 / inescapable / í”¼í•  ìˆ˜ ì—†ëŠ”
1542 / supervision / ê°ë…, ê´€ë¦¬, ì§€íœ˜
1543 / synthetic / í•©ì„±í•œ, ì¸ì¡°ì˜
1544 / peer / ì‘ì‹œí•˜ë‹¤, ìœ ì‹¬íˆ ë³´ë‹¤
1545 / reconstruct / ì¬êµ¬ì„±[ì¬í˜„]í•˜ë‹¤
1546 / enroll / ë“±ë¡í•˜ë‹¤
1547 / utilize / í™œìš©[ì´ìš©]í•˜ë‹¤
1548 / dignity / ìœ„ì—„, í’ˆìœ„, ì¡´ì—„(ì„±)
1549 / slay / ì£½ì´ë‹¤
1550 / presuppose / ìƒì •í•˜ë‹¤, ì „ì œë¡œ í•˜ë‹¤
1551 / examine / ê²€ì‚¬[ì¡°ì‚¬]í•˜ë‹¤
1552 / saturate / í¬í™”ì‹œí‚¤ë‹¤, í¬í™” ìƒíƒœë¥¼ ë§Œë“¤ë‹¤
1553 / generate / ë°œìƒì‹œí‚¤ë‹¤, ì´ˆë˜í•˜ë‹¤
1554 / sprout / ì‹¹ì´ ë‚˜ë‹¤
1555 / offend / ê¸°ë¶„ì„ ìƒí•˜ê²Œ í•˜ë‹¤
1556 / infancy / ìœ ì•„ê¸°
1557 / stink / ì•…ì·¨ë¥¼ í’ê¸°ë‹¤, ëƒ„ìƒˆê°€ ë‚˜ë‹¤
1558 / withdraw / ì·¨ì†Œ[ì² íšŒ]í•˜ë‹¤
1559 / paddle / ë…¸ë¥¼ ì “ë‹¤, ì²¨ë²™ê±°ë¦¬ë‹¤
1560 / propose / (ê³„íšÂ·ìƒê°ì„) ì œì•ˆ[ì œì‹œ]í•˜ë‹¤
1561 / submerge / ë¬¼ì†ì— ë„£ë‹¤[ì ê¸°ë‹¤]
1562 / overtake / ì¶”ì›”í•˜ë‹¤, ëŠ¥ê°€í•˜ë‹¤
1563 / expose / ë“œëŸ¬ë‚´ë‹¤, ë…¸ì¶œì‹œí‚¤ë‹¤
1564 / tariff / ê´€ì„¸
1565 / utterly / ì™„ì „íˆ, ìˆœì „íˆ, ì „í˜€
1566 / underestimate / ë„ˆë¬´ ì ê²Œ ì¡ë‹¤, ê³¼ì†Œí‰ê°€í•˜ë‹¤
1567 / undue / ì§€ë‚˜ì¹œ, ê³¼ë„í•œ
1568 / carve / ì¡°ê°í•˜ë‹¤, ìƒˆê¸°ë‹¤
1569 / descendant / ìì†, í›„ì˜ˆ
1570 / vein / ì •ë§¥, í˜ˆê´€
1571 / informative / ìœ ìµí•œ, êµìœ¡ì ì¸
1572 / predator / í¬ì‹ì
1573 / withhold / (~ì„) ì£¼ì§€ ì•Šë‹¤, ë³´ë¥˜í•˜ë‹¤
1574 / install / ì„¤ì¹˜í•˜ë‹¤, ì¥ì°©í•˜ë‹¤
1575 / absurd / ë¶ˆí•©ë¦¬í•œ
1576 / archaeology / ê³ ê³ í•™
1577 / apparatus / (ì‹ ì²´ì˜) ê¸°ê´€
1578 / acclaim / í™˜í˜¸, ê°ˆì±„
1579 / herald / ì•Œë¦¬ë‹¤, ë°œí‘œí•˜ë‹¤
1580 / succumb / êµ´ë³µí•˜ë‹¤, (ë³‘ ë“±ìœ¼ë¡œ) ì“°ëŸ¬ì§€ë‹¤
1581 / stack / ìŒ“ë‹¤, ìŒ“ì´ë‹¤
1582 / hostage / ì¸ì§ˆ
1583 / thrift / ì ˆì•½, ê²€ì•½
1584 / anonymous / ìµëª…ì¸, ì‹ ì› ë¶ˆëª…ì˜
1585 / landfill / ì“°ë ˆê¸° ë§¤ë¦½(ì§€)
1586 / astound / ê²½ì•…ì‹œí‚¤ë‹¤, í° ì¶©ê²©ì„ ì£¼ë‹¤
1587 / uphold / (ë²•Â·ì›ì¹™ ë“±ì„) ìœ ì§€í•˜ë‹¤, ì˜¹í˜¸í•˜ë‹¤
1588 / terrain / ì§€í˜•, ì§€ì—­
1589 / thermal / ì—´ì˜, ëœ¨ê±°ìš´
1590 / thrust / (ê±°ì¹ ê²Œ) ë°€ì¹˜ë‹¤, ì°Œë¥´ë‹¤
1591 / vegetation / ì´ˆëª©, ì‹ë¬¼
1592 / passionate / ì—´ì •ì ì¸, ì—´ë ¬í•œ
1593 / anthropology / ì¸ë¥˜í•™
1594 / aboriginal / (íŠ¹íˆ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„ì˜) ì›ì£¼ë¯¼ì˜
1595 / abide / (ê·œì¹™ì„) ì§€í‚¤ë‹¤
1596 / sediment / ì¹¨ì „[í‡´ì ]ë¬¼, ì•™ê¸ˆ
1597 / magnify / í™•ëŒ€í•˜ë‹¤, ì¦ëŒ€í•˜ë‹¤
1598 / respondent / ì‘ë‹µì
1599 / alleviate / ì™„í™”í•˜ë‹¤, ê²½ê°ì‹œí‚¤ë‹¤
1600 / alienate / ë©€ë¦¬í•˜ë‹¤, ì†Œì›í•˜ê²Œ í•˜ë‹¤
`;

/** =========================
 *  2) ì •ë°€ í•´ì„¤(ìˆ˜ë™) - í•„ìš”ì‹œ ì¶”ê°€
 *  ========================= */
const ETYMO_STRONG = {
  "impartial": [
    ["ì–´ì›/êµ¬ì„±", "im-(not) + partial(ë¶€ë¶„/í¸íŒŒì ì¸)"],
    ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„", "â€˜í¸íŒŒì (partial)â€™ì´ â€˜ì•„ë‹˜â€™ â†’ ê³µì •í•œ/í¸ê²¬ì´ ì—†ëŠ”"],
    ["ì˜¤ë‹µ ë°©ì§€", "partial=ë¶€ë¶„/í¸íŒŒ. impartial=ê·¸ ë°˜ëŒ€(ê³µì •)."]
  ],
  "intrinsic": [
    ["ì–´ì›/êµ¬ì„±", "intra-(ì•ˆìª½) ê³„ì—´ + -insic(ë‚´ì¬)"],
    ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„", "ì•ˆì— â€˜ë‚´ì¬â€™í•œ ì„±ì§ˆ â†’ ë³¸ì§ˆì ì¸/ê³ ìœ í•œ"],
    ["ì˜¤ë‹µ ë°©ì§€", "intrinsic(ë‚´ì¬) â†” extrinsic(ì™¸ì¬)."]
  ],
  "disseminate": [
    ["ì–´ì›/ê¸°ì›", "dis-(í©ì–´) + semin(ì”¨ì•—)"],
    ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„", "ì”¨ì•—ì„ í©ë¿Œë¦¬ë‹¤ â†’ ì •ë³´/ì‚¬ìƒì„ í¼ëœ¨ë¦¬ë‹¤"],
    ["ì•”ê¸°", "seed(ì”¨ì•—) ëŠë‚Œìœ¼ë¡œ â€˜ë„ë¦¬ í¼ì§â€™ ê³ ì •"]
  ],
  "nostalgia": [
    ["ì–´ì›/êµ¬ì„±", "nostos(ê·€í–¥) + algia(ê³ í†µ)"],
    ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„", "ì§‘/ê³¼ê±°ë¥¼ ê·¸ë¦¬ì›Œí•˜ëŠ” ì•„í”” â†’ í–¥ìˆ˜(ë³‘)"],
    ["ì•”ê¸°", "algia=í†µì¦(ì˜ˆ: neuralgia) â†’ â€˜ê·¸ë¦¬ì›€ì˜ ì•„í””â€™"]
  ],
};

/** =========================
 *  3) ìë™ í•´ì„¤(ê°œë³„í™”)
 *  ========================= */
const PREFIX = [
  ["anti", "ë°˜ëŒ€"], ["auto","ìŠ¤ìŠ¤ë¡œ"], ["bi","2"], ["co","í•¨ê»˜"], ["con","í•¨ê»˜/ì™„ì „íˆ"],
  ["counter","ë°˜ëŒ€/ìƒì‡„"], ["de","ë–¼ì–´/ì•„ë˜ë¡œ/ì—†ì• ë‹¤"], ["dis","ë–¼ì–´/ë°˜ëŒ€/ì—†ì• ë‹¤"],
  ["en","~í•˜ê²Œ í•˜ë‹¤/ë„£ë‹¤"], ["ex","ë°–ìœ¼ë¡œ/ì „-"], ["im","ë¶€ì •/ì•ˆìœ¼ë¡œ(in- ë³€í˜•)"],
  ["in","ë¶€ì •(ì•„ë‹ˆë‹¤)/ì•ˆ"], ["inter","ì‚¬ì´ì—/ì„œë¡œ"], ["mis","ì˜ëª»"], ["non","ì•„ë‹˜"],
  ["over","ê³¼í•˜ê²Œ"], ["pre","ì•/ë¯¸ë¦¬"], ["pro","ì•/ì°¬ì„±"], ["re","ë‹¤ì‹œ/ë’¤ë¡œ"],
  ["sub","ì•„ë˜/ë’¤"], ["trans","ê°€ë¡œì§ˆëŸ¬/ê±´ë„ˆ"], ["under","ì•„ë˜/ëœ"]
];

const SUFFIX = [
  ["tion","ëª…ì‚¬(ê³¼ì •/ê²°ê³¼)"], ["sion","ëª…ì‚¬(ê³¼ì •/ê²°ê³¼)"], ["ment","ëª…ì‚¬(í–‰ë™/ê²°ê³¼)"],
  ["ity","ëª…ì‚¬(ì„±ì§ˆ/ìƒíƒœ)"], ["ness","ëª…ì‚¬(ìƒíƒœ)"], ["ive","í˜•ìš©ì‚¬(ì„±ì§ˆ)"],
  ["al","í˜•ìš©ì‚¬(~ì˜)"], ["ic","í˜•ìš©ì‚¬(~ì˜)"], ["ous","í˜•ìš©ì‚¬(~í•œ)"],
  ["ly","ë¶€ì‚¬(~í•˜ê²Œ)"], ["able","í˜•ìš©ì‚¬(~í•  ìˆ˜ ìˆëŠ”)"], ["ible","í˜•ìš©ì‚¬(~í•  ìˆ˜ ìˆëŠ”)"],
  ["ize","ë™ì‚¬(~í™”í•˜ë‹¤)"], ["ify","ë™ì‚¬(~í•˜ê²Œ í•˜ë‹¤)"], ["ence","ëª…ì‚¬(ì„±ì§ˆ)"], ["ance","ëª…ì‚¬(ì„±ì§ˆ)"],
  ["ary","í˜•ìš©ì‚¬(~ì˜)"], ["ent","í˜•ìš©ì‚¬/ëª…ì‚¬"], ["ant","í˜•ìš©ì‚¬/ëª…ì‚¬"]
];

const ROOTS = [
  ["part", "ë¶€ë¶„"], ["cred", "ë¯¿ë‹¤"], ["aud", "ë“£ë‹¤"], ["dict", "ë§í•˜ë‹¤"],
  ["scrib", "ì“°ë‹¤"], ["script", "ì“°ë‹¤"], ["graph", "ê¸°ë¡"],
  ["port", "ì˜®ê¸°ë‹¤"], ["fer", "ì˜®ê¸°ë‹¤"], ["mit", "ë³´ë‚´ë‹¤"], ["miss", "ë³´ë‚´ë‹¤"],
  ["duc", "ì´ëŒë‹¤"], ["duct", "ì´ëŒë‹¤"], ["tract", "ëŒë‹¤"],
  ["press", "ëˆ„ë¥´ë‹¤"], ["struct", "ì„¸ìš°ë‹¤/ìŒ“ë‹¤"], ["gen", "íƒœì–´ë‚˜ë‹¤/ë§Œë“¤ë‹¤"],
  ["terr", "ë•…/ì§€ì—­"], ["bio", "ìƒëª…"], ["archae", "ê³ ëŒ€"], ["therm", "ì—´"],
  ["spect", "ë³´ë‹¤"], ["vid", "ë³´ë‹¤"], ["vis", "ë³´ë‹¤"], ["semin", "ì”¨ì•—"],
  ["vert", "ëŒë¦¬ë‹¤"], ["ceed", "ê°€ë‹¤"], ["cess", "ê°€ë‹¤"], ["sid", "ì•‰ë‹¤"],
  ["rupt", "ê¹¨ì§€ë‹¤"], ["stalk", "ì¤„ê¸°"], ["vege", "ì‹ë¬¼"], ["magn", "í¬ë‹¤"]
];

function normalizeWord(w){ return String(w||"").toLowerCase().trim(); }

function detectPrefix(w){
  for (const [p, mean] of PREFIX) {
    if (w.startsWith(p) && w.length > p.length + 2) return [p, mean];
  }
  return null;
}
function detectSuffix(w){
  for (const [s, mean] of SUFFIX) {
    if (w.endsWith(s) && w.length > s.length + 2) return [s, mean];
  }
  return null;
}
function detectRoots(w){
  const found = [];
  const sorted = [...ROOTS].sort((a,b)=>b[0].length - a[0].length);
  for (const [r, mean] of sorted) {
    if (w.includes(r) && w.length > r.length + 1) {
      found.push([r, mean]);
      if (found.length >= 2) break;
    }
  }
  return found;
}
function inferPos(meaningKo){
  const m = String(meaningKo||"");
  if (m.includes("í•˜ë‹¤") || m.includes("ë˜ë‹¤")) return "ë™ì‚¬";
  if (m.includes("ì ì¸") || m.endsWith("ì˜")) return "í˜•ìš©ì‚¬";
  if (m.includes("í•˜ê²Œ")) return "ë¶€ì‚¬";
  return "ì–´íœ˜";
}
function buildMeaningChain(pre, roots, suf){
  const steps = [];
  if (pre) steps.push(`â‘  ${pre[0]} = â€œ${pre[1]}â€`);
  if (roots.length) {
    roots.forEach((r, i) => steps.push(`${pre ? (i===0 ? "â‘¡" : "â‘¢") : (i===0 ? "â‘ ":"â‘¡")} ${r[0]} = â€œ${r[1]}â€`));
  }
  if (suf) steps.push(`ë§ˆì§€ë§‰: -${suf[0]} = â€œ${suf[1]}â€`);
  if (!steps.length) steps.push("â‘  (ë¶„í•´ ë‹¨ì„œ ì•½í•¨) â†’ â€˜ëŒ€í‘œ ì¥ë©´(ì´ë¯¸ì§€)â€™ë¡œ ì˜ë¯¸ ê³ ì •");
  return steps.join(" â†’ ");
}
function buildAntiConfusion(word, pre, suf){
  const tips = [];
  if (pre && pre[0] === "re") tips.push("re- = ë‹¤ì‹œ/ë’¤ë¡œ (ë°˜ëŒ€ X)");
  if (pre && pre[0] === "dis") tips.push("dis- = ë¶„ë¦¬/ì œê±°/ë°˜ëŒ€ (in- ë¶€ì •ê³¼ êµ¬ë¶„)");
  if (pre && pre[0] === "inter") tips.push("inter- = ì‚¬ì´/ì„œë¡œ (ë¼ì–´ë“¤ê¸° ì´ë¯¸ì§€)");
  if (pre && pre[0] === "over") tips.push("over- = ê³¼í•˜ê²Œ(ê³¼ì¥/ê³¼ë‹¤)");
  if (pre && pre[0] === "under") tips.push("under- = ëœ/ì•„ë˜(ê³¼ì†Œ/ë¶€ì¡±)");
  if (suf && suf[0] === "tion") tips.push("-tion = ëª…ì‚¬(ê³¼ì •/ê²°ê³¼)");
  if (suf && suf[0] === "ity") tips.push("-ity = ~ì„±/ìƒíƒœ");
  if (word.endsWith("ly")) tips.push("-ly = ë¶€ì‚¬(~í•˜ê²Œ)");
  if (!tips.length) tips.push("í•µì‹¬ ì´ë¯¸ì§€ 1ê°œë§Œ ê³ ì •í•˜ë©´ ì˜¤ë‹µì´ í™• ì¤„ì–´ìš”.");
  return tips.join(" / ");
}
function autoEtymo(word, meaningKo){
  const w = normalizeWord(word);
  const pre = detectPrefix(w);
  const suf = detectSuffix(w);
  const roots = detectRoots(w);
  const pos = inferPos(meaningKo);

  const breakdown = [];
  if (pre) breakdown.push(`${pre[0]}- (${pre[1]})`);
  if (roots.length) breakdown.push(...roots.map(r => `${r[0]} (${r[1]})`));
  if (suf) breakdown.push(`-${suf[0]} (${suf[1]})`);
  if (!breakdown.length) breakdown.push(`${w} (ë¶„í•´ ë‹¨ì„œ ì•½í•¨)`);

  const chain = buildMeaningChain(pre, roots, suf);
  const anti = buildAntiConfusion(w, pre, suf);

  const reason = (() => {
    if (pre || suf || roots.length) {
      const core = roots.length ? roots.map(r=>r[1]).join(" + ") : "í•µì‹¬ ì˜ë¯¸";
      const dir = pre ? `â€œ${pre[1]}â€ ë°©í–¥ì„ ë¨¼ì € ì¡ê³ , ` : "";
      const tail = suf ? ` ë§ˆì§€ë§‰ì— â€œ${suf[1]}â€ë¡œ í’ˆì‚¬/ëŠë‚Œì„ ê³ ì •í•©ë‹ˆë‹¤.` : " ë¬¸ë§¥ì— ë§ê²Œ í’ˆì‚¬ë¥¼ ê³ ì •í•©ë‹ˆë‹¤.";
      return `${dir}${core}ë¥¼ ë¶™ì´ë©´ ëœ»ì´ ì—°ê²°ë¼ìš”.${tail} (í’ˆì‚¬: ${pos})`;
    }
    return `ì´ ë‹¨ì–´ëŠ” ë¶„í•´ë³´ë‹¤ â€˜ì¥ë©´â€™ì´ í•µì‹¬ì…ë‹ˆë‹¤. ${w}ê°€ ì“°ì¼ ìƒí™©ì„ 1ê°œ ë– ì˜¬ë ¤ ëœ»ì„ ê³ ì •í•˜ì„¸ìš”. (í’ˆì‚¬: ${pos})`;
  })();

  const mnemonic = (() => {
    const parts = [];
    if (pre) parts.push(`${pre[0]}(${pre[1]})`);
    if (roots.length) parts.push(...roots.map(r=>`${r[0]}(${r[1]})`));
    if (suf) parts.push(`-${suf[0]}(${suf[1]})`);
    if (parts.length) return `ì•”ê¸°: ${w} â‰ˆ ${parts.join(" + ")} â†’ ëœ»ì„ â€œ${parts.map(p=>p.split("(")[1].replace(")","")).join(" + ")}â€ë¡œ ì—°ê²°.`;
    return `ì•”ê¸°: ${w}ëŠ” ëŒ€í‘œ ì¥ë©´ 1ê°œë¡œ ì™¸ìš°ê¸°(ì˜ˆ: í–‰ë™/ìƒí™©ì„ ê·¸ë¦¼ì²˜ëŸ¼ ë– ì˜¬ë¦¬ê¸°).`;
  })();

  return [
    ["ì–´ì›/êµ¬ì„±(ìë™Â·ê°œë³„)", breakdown.join(" + ")],
    ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„(ìë™Â·ê°œë³„)", chain],
    ["ì™œ ì´ëŸ° ëœ»ì´ ë˜ë‚˜(ìë™Â·ê°œë³„)", reason],
    ["ì¤‘2 ì•”ê¸°(ìë™Â·ê°œë³„)", mnemonic],
    ["ì˜¤ë‹µ ë°©ì§€(ìë™Â·ê°œë³„)", anti]
  ];
}
function getEtymoCard(word, meaningKo) {
  const key = normalizeWord(word);
  if (ETYMO_STRONG[key]) return ETYMO_STRONG[key];
  return autoEtymo(key, meaningKo);
}

/** =========================
 *  4) íŒŒì‹±
 *  ========================= */
function parseEntries(raw) {
  const lines = raw.split(/\r?\n/);
  const out = [];
  // "1451 / word / meaning"
  const re = /^\s*(\d{4})\s*\/\s*([A-Za-z-]+)\s*\/\s*(.+?)\s*$/;
  for (const line of lines) {
    const m = line.match(re);
    if (!m) continue;
    out.push({ num: parseInt(m[1],10), word: m[2].trim(), meaning: m[3].trim() });
  }
  return out;
}
const ALL = parseEntries(RAW);

/** =========================
 *  5) ìœ ì‚¬ ì˜¤ë‹µ ìƒì„±
 *  ========================= */
function pickDistractors(correctMeaning, poolMeanings, count=3) {
  const len = correctMeaning.length;
  const similar = poolMeanings.filter(m => m !== correctMeaning && Math.abs(m.length - len) <= 6);

  const picked = new Set();
  function takeFrom(arr) {
    const shuffled = shuffle([...arr]);
    for (const x of shuffled) {
      if (picked.size >= count) break;
      if (x === correctMeaning) continue;
      picked.add(x);
    }
  }
  takeFrom(similar);
  if (picked.size < count) takeFrom(poolMeanings);
  return [...picked].slice(0, count);
}
function buildQuestions(entries) {
  const meanings = entries.map(e => e.meaning);
  return entries.map(e => {
    const correct = e.meaning;
    const distractors = pickDistractors(correct, meanings, 3);
    const options = shuffle([correct, ...distractors]);
    const correctIndex = options.indexOf(correct);
    return { num: e.num, word: e.word, meaning: e.meaning, options, correctIndex };
  });
}

/** =========================
 *  6) ìƒíƒœ/ì €ì¥ + ìŠ¤ì½”ì–´ë³´ë“œ
 *  ========================= */
const dom = {
  pillCount: document.getElementById("pillCount"),
  pillProgress: document.getElementById("pillProgress"),
  pillScore: document.getElementById("pillScore"),
  bar: document.getElementById("bar"),
  qbox: document.getElementById("qbox"),
  summary: document.getElementById("summary"),
  rangeSelect: document.getElementById("rangeSelect"),
  shuffleToggle: document.getElementById("shuffleToggle"),
  saveToggle: document.getElementById("saveToggle"),
  autoPronounceToggle: document.getElementById("autoPronounceToggle"),
  btnStart: document.getElementById("btnStart"),
  btnWrongOnly: document.getElementById("btnWrongOnly"),
  btnReset: document.getElementById("btnReset"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
  sbAnswered: document.getElementById("sbAnswered"),
  sbCorrect: document.getElementById("sbCorrect"),
  sbWrong: document.getElementById("sbWrong"),
  sbStreak: document.getElementById("sbStreak"),
  sbNote: document.getElementById("sbNote"),
};

function getKey() {
  const range = dom.rangeSelect.value;
  return `vocab_quiz_1451_1600_etymo_${range}_v1_pronounce_scoreboard`;
}

function defaultState(total) {
  return {
    idx: 0,
    selected: Array(total).fill(null),
    checked: Array(total).fill(false),
    score: 0,
    wrong: [],
    order: [...Array(total).keys()],
    answeredCount: 0,
    correctCount: 0,
    wrongCount: 0,
    streak: 0,
    bestStreak: 0
  };
}

function normalizeLoadedState(s, total) {
  const base = defaultState(total);
  const out = { ...base, ...s };

  if (!Array.isArray(out.selected) || out.selected.length !== total) out.selected = base.selected;
  if (!Array.isArray(out.checked) || out.checked.length !== total) out.checked = base.checked;
  if (!Array.isArray(out.order) || out.order.length !== total) out.order = base.order;
  if (!Array.isArray(out.wrong)) out.wrong = [];
  for (const k of ["idx","score","answeredCount","correctCount","wrongCount","streak","bestStreak"]) {
    out[k] = Number.isFinite(out[k]) ? out[k] : base[k];
  }
  out.idx = Math.max(0, Math.min(total-1, out.idx));
  return out;
}

let quiz = { entries: [], questions: [], state: null };

function saveState() {
  if (!dom.saveToggle.checked) return;
  localStorage.setItem(getKey(), JSON.stringify(quiz.state));
}

function loadState(total) {
  if (!dom.saveToggle.checked) return null;
  try {
    const raw = localStorage.getItem(getKey());
    if (!raw) return null;
    const s = JSON.parse(raw);
    if (!s) return null;
    return normalizeLoadedState(s, total);
  } catch { return null; }
}

function filterByRange(rangeStr) {
  const [a,b] = rangeStr.split("-").map(x => parseInt(x,10));
  return ALL.filter(e => e.num >= a && e.num <= b);
}

function updateScoreboard() {
  if (!quiz.state) {
    dom.sbAnswered.textContent = "0";
    dom.sbCorrect.textContent = "0";
    dom.sbWrong.textContent = "0";
    dom.sbStreak.textContent = "0";
    dom.sbNote.textContent = "";
    return;
  }
  const s = quiz.state;
  dom.sbAnswered.textContent = String(s.answeredCount);
  dom.sbCorrect.textContent = String(s.correctCount);
  dom.sbWrong.textContent = String(s.wrongCount);
  dom.sbStreak.textContent = String(s.streak);
  dom.sbNote.textContent = `ìµœê³  ì—°ì† ì •ë‹µ: ${s.bestStreak}íšŒ`;
}

/** =========================
 *  7) ë Œë”
 *  ========================= */
function render() {
  updateScoreboard();

  if (!quiz.state) {
    dom.qbox.innerHTML = `<div class="small muted">ìƒë‹¨ì—ì„œ ë²”ìœ„ë¥¼ ì„ íƒí•˜ê³  â€œí€´ì¦ˆ ì‹œì‘/ì¬ì‹œì‘â€ì„ ëˆ„ë¥´ì„¸ìš”.</div>`;
    dom.pillCount.textContent = `ë¬¸í•­: 0`;
    dom.pillProgress.textContent = `ì§„í–‰: 0/0`;
    dom.pillScore.textContent = `ì ìˆ˜: 0`;
    dom.bar.style.width = "0%";
    dom.btnPrev.disabled = true;
    dom.btnNext.disabled = true;
    dom.btnWrongOnly.disabled = true;
    dom.summary.innerHTML = "";
    return;
  }

  const total = quiz.questions.length;
  const s = quiz.state;
  const done = s.checked.filter(Boolean).length;

  dom.pillCount.textContent = `ë¬¸í•­: ${total}`;
  dom.pillProgress.textContent = `ì§„í–‰: ${done}/${total}`;
  dom.pillScore.textContent = `ì ìˆ˜: ${s.score}`;
  dom.bar.style.width = `${Math.round((done/total)*100)}%`;

  dom.btnPrev.disabled = s.idx === 0;
  dom.btnNext.disabled = s.idx === total - 1;

  const qIndex = s.order[s.idx];
  const q = quiz.questions[qIndex];

  const chosen = s.selected[s.idx];
  const checked = s.checked[s.idx];

  dom.qbox.innerHTML = `
    <div class="qhead">
      <div class="qnum">Q${s.idx+1} / ${total} <span class="meta">(ë‹¨ì–´ë²ˆí˜¸ ${q.num})</span></div>
    </div>

    <div class="qhead" style="margin-top:8px;">
      <div class="word">${escapeHtml(q.word)}</div>
      <button class="iconbtn" id="btnSpeak" title="ë¯¸êµ­ì‹ ë°œìŒ ì¬ìƒ">ğŸ”Š ë°œìŒ ë“£ê¸°</button>
      <span class="mini muted">${"speechSynthesis" in window ? "US ë°œìŒ(TTS)" : "ì´ ë¸Œë¼ìš°ì €ëŠ” ë°œìŒ ê¸°ëŠ¥ ë¯¸ì§€ì›"}</span>
    </div>

    <div class="choices" id="choices"></div>
    <div id="resultArea"></div>
  `;

  const btnSpeak = document.getElementById("btnSpeak");
  btnSpeak.disabled = !("speechSynthesis" in window);
  btnSpeak.addEventListener("click", () => {
    userInteracted = true;
    speakWord(q.word, {force:true});
  });

  const choicesEl = document.getElementById("choices");
  q.options.forEach((text, idx0) => {
    let cls = "choice";
    if (chosen === idx0) cls += " selected";
    if (checked) {
      if (idx0 === q.correctIndex) cls += " correct";
      else if (chosen === idx0 && chosen !== q.correctIndex) cls += " wrong";
    }
    const el = document.createElement("div");
    el.className = cls;
    el.innerHTML = `<div class="tag">${idx0+1}</div><div>${escapeHtml(text)}</div>`;
    el.addEventListener("click", () => {
      userInteracted = true;
      if (s.checked[s.idx]) return;
      s.selected[s.idx] = idx0;
      checkAnswer();
    });
    choicesEl.appendChild(el);
  });

  const resultArea = document.getElementById("resultArea");

  if (checked) {
    const ok = chosen === q.correctIndex;

    let etymoHtml = "";
    if (!ok) {
      const card = getEtymoCard(q.word, q.meaning);
      const safeCard = (Array.isArray(card) && card.length)
        ? card
        : [
            ["ì–´ì›/êµ¬ì„±(ê¸°ë³¸)", "ì´ ë‹¨ì–´ëŠ” â€˜í•µì‹¬ ì´ë¯¸ì§€â€™ë¡œ ì™¸ìš°ëŠ” ê²Œ ì¢‹ìŠµë‹ˆë‹¤."],
            ["ëœ»ì´ ë§Œë“¤ì–´ì§„ íë¦„(ê¸°ë³¸)", "ì´ë¯¸ì§€ â†’ ë¬¸ë§¥ â†’ ëœ» ì—°ê²° ìˆœì„œë¡œ ê¸°ì–µí•˜ì„¸ìš”."],
            ["ì¤‘2 ì•”ê¸° íŒ(ê¸°ë³¸)", "ì˜¤ëŠ˜ì€ â€˜ê·¸ë¦¼ 1ê°œâ€™ë§Œ ê³ ì •í•´ë„ ì˜¤ë‹µì´ ì¤„ì–´ìš”."]
          ];

      etymoHtml = `
        <div class="etymo">
          <div class="title">ì˜¤ë‹µ ê°ì†Œ í•´ì„¤ (ì–´ì›/ì˜ë¯¸ ìƒì„±/ì•”ê¸°)</div>
          <div class="small muted">
            ë‹¨ì–´: <span class="kbd">${escapeHtml(q.word)}</span>
            <span style="margin-left:8px;">(í•´ì„¤ í•­ëª©: ${safeCard.length}ê°œ)</span>
          </div>
          <ul class="small">
            ${safeCard.map(([k,v]) => `<li><b>${escapeHtml(k)}</b>: ${escapeHtml(v)}</li>`).join("")}
          </ul>
        </div>
      `;
    }

    resultArea.innerHTML = `
      <div class="result ${ok ? "good" : "bad"}">
        <div><b>${ok ? "ì •ë‹µ!" : "ì˜¤ë‹µ"}</b></div>
        <div class="small">
          ì •ë‹µ: <b>${q.correctIndex+1}</b> (${escapeHtml(q.options[q.correctIndex])})<br/>
          ì„ íƒ: <b>${chosen+1}</b> (${escapeHtml(q.options[chosen])})
        </div>
      </div>
      ${etymoHtml}
    `;
  } else {
    resultArea.innerHTML = `<div class="small muted" style="margin-top:10px;">ë³´ê¸°(ë‹µì•ˆ)ë¥¼ ëˆ„ë¥´ë©´ ë°”ë¡œ ì±„ì ë©ë‹ˆë‹¤.</div>`;
  }

  if (done === total) renderSummary();
  else dom.summary.innerHTML = "";

  dom.btnWrongOnly.disabled = (done === 0);

  if (dom.autoPronounceToggle.checked && userInteracted) {
    setTimeout(() => {
      speakWord(q.word, {force:false});
    }, 80);
  }
}

function renderSummary() {
  const total = quiz.questions.length;
  const s = quiz.state;
  const wrongOnly = s.wrong;

  dom.summary.innerHTML = `
    <div class="hr"></div>
    <div class="row">
      <div>
        <div style="font-weight:1000; font-size:18px;">ê²°ê³¼</div>
        <div class="small">ì´ì : <b>${s.score}</b> / ${total}</div>
        <div class="small muted">ì™„ë£Œ: ${total}ë¬¸í•­</div>
      </div>
      <div class="row">
        <button class="btn secondary" id="btnGoFirst">ì²« ë¬¸ì œë¡œ</button>
      </div>
    </div>

    <details ${wrongOnly.length ? "open" : ""}>
      <summary>ì˜¤ë‹µ ë…¸íŠ¸ (${wrongOnly.length}ê°œ)</summary>
      ${wrongOnly.length ? `
      <table>
        <thead>
          <tr><th>Q</th><th>ë‹¨ì–´</th><th>ë‚´ ì„ íƒ</th><th>ì •ë‹µ</th></tr>
        </thead>
        <tbody>
          ${wrongOnly.map(w => `
            <tr>
              <td>${w.qNo}</td>
              <td><b>${escapeHtml(w.word)}</b></td>
              <td>${escapeHtml(w.chosenText)}</td>
              <td>${escapeHtml(w.correctText)}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>` : `<div class="small muted" style="margin-top:10px;">ì˜¤ë‹µì´ ì—†ìŠµë‹ˆë‹¤.</div>`}
    </details>
  `;

  document.getElementById("btnGoFirst").addEventListener("click", () => {
    quiz.state.idx = 0;
    saveState();
    render();
  });
}

function checkAnswer() {
  const s = quiz.state;
  const qIndex = s.order[s.idx];
  const q = quiz.questions[qIndex];

  const chosen = s.selected[s.idx];
  if (chosen === null || s.checked[s.idx]) return;

  s.checked[s.idx] = true;
  s.answeredCount += 1;

  if (chosen === q.correctIndex) {
    s.score += 1;
    s.correctCount += 1;
    s.streak += 1;
    if (s.streak > s.bestStreak) s.bestStreak = s.streak;
  } else {
    s.wrongCount += 1;
    s.streak = 0;

    const qNo = s.idx + 1;
    if (!s.wrong.some(x => x.qNo === qNo)) {
      s.wrong.push({
        qNo,
        word: q.word,
        chosenText: q.options[chosen],
        correctText: q.options[q.correctIndex],
      });
    }
  }

  saveState();
  render();
}

function startQuiz({ wrongOnly=false } = {}) {
  userInteracted = true;
  lastSpokenKey = "";

  const range = dom.rangeSelect.value;
  const entries = filterByRange(range);
  const questions = buildQuestions(entries);

  const total = questions.length;
  const baseState = defaultState(total);
  if (dom.shuffleToggle.checked) baseState.order = shuffle(baseState.order);

  const loaded = loadState(total);

  quiz.entries = entries;
  quiz.questions = questions;
  quiz.state = loaded ?? baseState;

  if (wrongOnly && loaded?.wrong?.length) {
    const wrongWords = new Set(loaded.wrong.map(w => w.word.toLowerCase()));
    const wrongEntries = entries.filter(e => wrongWords.has(e.word.toLowerCase()));
    if (wrongEntries.length) {
      quiz.entries = wrongEntries;
      quiz.questions = buildQuestions(wrongEntries);
      quiz.state = defaultState(quiz.questions.length);
      if (dom.shuffleToggle.checked) quiz.state.order = shuffle(quiz.state.order);
    }
  }

  saveState();
  render();
}

/** ===== ìœ í‹¸ ===== */
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

/** ===== ì´ë²¤íŠ¸ ===== */
dom.btnStart.addEventListener("click", () => startQuiz({ wrongOnly:false }));
dom.btnWrongOnly.addEventListener("click", () => startQuiz({ wrongOnly:true }));

dom.btnReset.addEventListener("click", () => {
  userInteracted = true;
  if (!confirm("ì„ íƒí•œ ë²”ìœ„ì˜ ì €ì¥ëœ ì§„í–‰ìƒí™©ì„ ì™„ì „ ì´ˆê¸°í™”í• ê¹Œìš”?")) return;
  localStorage.removeItem(getKey());
  quiz.state = null;
  lastSpokenKey = "";
  render();
});

dom.btnPrev.addEventListener("click", () => {
  userInteracted = true;
  if (!quiz.state) return;
  quiz.state.idx = Math.max(0, quiz.state.idx - 1);
  saveState();
  render();
});
dom.btnNext.addEventListener("click", () => {
  userInteracted = true;
  if (!quiz.state) return;
  quiz.state.idx = Math.min(quiz.questions.length - 1, quiz.state.idx + 1);
  saveState();
  render();
});

dom.rangeSelect.addEventListener("change", () => {
  quiz.state = null;
  lastSpokenKey = "";
  render();
});

dom.saveToggle.addEventListener("change", () => {
  userInteracted = true;
  if (!dom.saveToggle.checked) {
    alert("ìë™ ì €ì¥ì´ êº¼ì¡ŒìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨í•˜ë©´ ì§„í–‰ìƒí™©ì´ ìœ ì§€ë˜ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.");
  }
});

dom.autoPronounceToggle.addEventListener("change", () => {
  userInteracted = true;
  if (dom.autoPronounceToggle.checked && quiz.state) {
    const s = quiz.state;
    const qIndex = s.order[s.idx];
    const q = quiz.questions[qIndex];
    speakWord(q.word, {force:true});
  }
});

render();
</script>
</body>
</html>
