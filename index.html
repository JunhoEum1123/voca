<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ✅ PWA: manifest + iOS 홈화면(앱처럼) -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0b0c10">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="VocabQuiz">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <title>Vocabulary Quiz 1200–1450 (오답 어원/의미 생성 해설 강화)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
    body { margin: 0; background: #0b0c10; color: #e7e7e7; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .card { background: #14161d; border: 1px solid #232636; border-radius: 14px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    h1 { margin: 0 0 10px; font-size: 20px; }
    .sub { opacity: .8; font-size: 13px; margin-bottom: 14px; line-height: 1.45; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .pill { background:#1c2030; border:1px solid #2b3250; padding: 6px 10px; border-radius: 999px; font-size: 12px; }
    .btn { background:#2a63ff; border:0; color:white; padding:10px 12px; border-radius: 10px; cursor:pointer; font-weight:800; }
    .btn.secondary { background:#2b3250; }
    .btn.danger { background:#ff3b3b; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .progressbar { height: 10px; background:#0f1118; border:1px solid #232636; border-radius:999px; overflow:hidden; margin-top: 10px; }
    .bar { height:100%; width:0%; background:#2a63ff; }
    .qbox { margin-top: 14px; }
    .qhead { display:flex; gap:12px; align-items:baseline; flex-wrap:wrap; }
    .qnum { font-weight:900; font-size: 14px; opacity:.9; }
    .word { font-size: 28px; font-weight:900; letter-spacing:.3px; }
    .meta { font-size: 12px; opacity:.8; }
    .choices { display:grid; gap:10px; margin-top: 14px; }
    .choice {
      background:#0f1118; border:1px solid #2b3250; border-radius: 12px;
      padding: 12px; cursor:pointer; display:flex; gap:10px; align-items:flex-start;
      transition: transform .05s ease;
    }
    .choice:hover { transform: translateY(-1px); }
    .choice.selected { border-color:#86a3ff; background:#121a34; }
    .choice.correct { border-color:#35d07f; background:#0f1f18; }
    .choice.wrong { border-color:#ff6b6b; background:#231012; }
    .tag { font-weight:900; width: 26px; text-align:center; opacity:.9; }
    .result { margin-top: 12px; padding: 12px; border-radius: 12px; border:1px solid #2b3250; background:#0f1118; }
    .result.good { border-color:#35d07f; background:#0f1f18; }
    .result.bad { border-color:#ff6b6b; background:#231012; }
    .small { font-size: 13px; opacity:.9; line-height:1.5; }
    .footer { margin-top: 14px; display:flex; gap:10px; flex-wrap:wrap; }
    details { margin-top: 14px; }
    summary { cursor:pointer; font-weight:900; }
    table { width:100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom:1px solid #232636; padding: 10px 6px; text-align:left; font-size: 13px; }
    th { opacity:.85; }
    .muted { opacity:.7; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 10px; }
    select, input[type="checkbox"] { accent-color: #2a63ff; }
    select {
      background:#0f1118; color:#e7e7e7; border:1px solid #2b3250;
      border-radius: 10px; padding: 8px 10px; font-weight:700;
    }
    label { font-size: 13px; opacity:.9; display:flex; gap:8px; align-items:center; }
    .hr { border:0; border-top:1px solid #232636; margin:16px 0; }
    .etymo {
      margin-top: 10px;
      padding: 12px;
      border: 1px dashed #2b3250;
      border-radius: 12px;
      background: rgba(30,34,52,.35);
    }
    .etymo .title { font-weight:900; margin-bottom: 6px; }
    .etymo ul { margin: 8px 0 0; padding-left: 18px; }
    .etymo li { margin: 6px 0; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; padding: 2px 6px; border:1px solid #2b3250; border-radius: 8px; background:#0f1118; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row">
        <div>
          <h1>Vocabulary Quiz (1200–1450) — 오답 어원/의미 생성 해설(강화)</h1>
          <div class="sub">
            - 단어 1개당 <b>유사 오답 3개</b> 자동 생성 → <b>4지선다</b><br/>
            - <b>오답일 때만</b> “왜 그 뜻이 되는지”를 <b>단어별로</b> (구성 → 의미 생성 → 암기/오답 방지)로 자세히 보여줍니다.<br/>
            - ✅ <b>보기 하나를 누르면 즉시 채점</b> (정답/오답 + 오답 해설 즉시 표시)
          </div>
        </div>
        <div class="row">
          <div class="pill" id="pillCount">문항: 0</div>
          <div class="pill" id="pillProgress">진행: 0/0</div>
          <div class="pill" id="pillScore">점수: 0</div>
        </div>
      </div>

      <div class="controls">
        <label>범위
          <select id="rangeSelect">
            <option value="1200-1450" selected>1200–1450 (전체)</option>
            <option value="1200-1219">1200–1219</option>
            <option value="1220-1239">1220–1239</option>
            <option value="1240-1259">1240–1259</option>
            <option value="1260-1279">1260–1279</option>
            <option value="1280-1299">1280–1299</option>
            <option value="1300-1319">1300–1319</option>
            <option value="1320-1339">1320–1339</option>
            <option value="1340-1450">1340–1450</option>
          </select>
        </label>

        <label><input type="checkbox" id="shuffleToggle" checked /> 문제 순서 섞기</label>
        <label><input type="checkbox" id="saveToggle" checked /> 진행상황 자동 저장</label>

        <button class="btn" id="btnStart">퀴즈 시작/재시작</button>
        <button class="btn secondary" id="btnWrongOnly" disabled>오답만 다시</button>
        <button class="btn danger" id="btnReset">완전 초기화</button>
      </div>

      <div class="progressbar" aria-label="progress">
        <div class="bar" id="bar"></div>
      </div>

      <div class="qbox" id="qbox"></div>

      <div class="footer">
        <button class="btn secondary" id="btnPrev">이전</button>
        <button class="btn secondary" id="btnCheck" title="(이제 자동 채점이라 선택 시 바로 채점됩니다)">정답 확인</button>
        <button class="btn" id="btnNext">다음</button>
      </div>

      <div id="summary"></div>
    </div>
  </div>

<script>
/** =========================
 *  1) 원문 데이터(사용자 제공)
 *  ========================= */
const RAW = String.raw`
1200–1219

1200 logical / 논리적인
1201 credibility / 신뢰성
1202 auditory / 청각의, 귀의
1203 scrutinize / 자세히 조사하다
1204 cooperate / 협력(협동)하다
1205 reciprocal / 상호 간의, 호혜적인
1206 exclusive / 배타적인
1207 forfeit / 박탈(몰수)당하다
1208 rebellious / 반역의
1209 retreat / 후퇴하다, 물러서다
1210 prudence / 신중, 사려 분별
1211 aid / 원조, 지원
1212 replicate / 모사하다, 반복하다
1213 pasture / 초원, 목초지
1214 prospect / (미래의) 전망, 예상
1215 qualify / ~에게 자격을 주다, 자격을 얻다
1216 rid / 없애다, 제거하다
1217 involuntarily / 무심결에, 본의 아니게
1218 assure / ~을 확실하게 하다
1219 periodic / 주기적인

1220–1239

1220 revert / 되돌아가다
1221 combustion / 불이 탐, 연소
1222 sneak / 살금살금(몰래) 들어오다
1223 ban / 금지하다
1224 collapse / 붕괴
1225 sprint / 전력 질주하다
1226 shatter / 산산이 부서지다
1227 debt / 빚, 부채
1228 diploma / 졸업장, 수료증
1229 flip / 홱 뒤집다, 가볍게 던지다
1230 acquaint / 알게 하다, 숙지시키다
1231 translate / 번역하다
1232 implement / 시행하다
1233 impulse / 충동, 욕구
1234 inhabitant / (특정 지역의) 주민, 서식 동물
1235 interfere / 간섭하다, 방해하다
1236 shield / 보호하다
1237 irrelevant / 상관없는, 무관한
1238 initially / 처음에, 시초에
1239 tame / 길들여진

1240–1259

1240 agent / 직원, 요원
1241 decline / 감소하다, 쇠퇴하다
1242 courtesy / 정중함, 공손함
1243 rattle / 덜거덕거리다, 달걀거리다
1244 wrap / 싸다, 포장하다
1245 stir / 동요, 충격
1246 discard / 버리다, 폐기하다
1247 reference / 추천서
1248 convert / 전환(변환)하다
1249 spur / ~에 박차를 가하다, 자극하다
1250 dismiss / 묵살하다
1251 sentiment / 정서, 감정
1252 odd / 이상한
1253 grasp / 이해하다, 파악하다
1254 constitute / 구성하다
1255 skeptical / 회의적인, 의심 많은
1256 astrology / 점성술, 점성학
1257 intimate / 사적인, 개인적인
1258 promotion / 홍보, 판매 촉진
1259 miserable / 비참한, 불행한

1260–1279

1260 permit / 허락하다, 허가하다
1261 summit / 꼭대기, 정상
1262 snatch / 잡아채다
1263 refuge / 피난(처), 도피(처)
1264 integrity / 성실, 정직
1265 stick / 꼼짝 못하다
1266 testimony / 증거, 증언
1267 federal / 연방의, 연합의
1268 superficial / 피상적인, 표면적인
1269 tolerate / 참다, 용인하다
1270 turnover / (직원의) 이직률
1271 versus / ~대, ~와 대비하여
1272 violate / 위반하다
1273 altruism / 이타주의, 이타심
1274 upright / 똑바른, 곧곧한
1275 bound / ~할 것 같은, ~이 틀림없는
1276 corporate / 기업의, 법인의
1277 defeat / 패배, 실패
1278 desperate / 절망적인
1279 disability / 장애, 불리한 조건

1280–1299

1280 endure / 참다, 견디다
1281 gaze / 응시하다, 바라보다
1282 ambivalent / 양면 가치의
1283 inherit / 상속받다, 물려받다
1284 antibody / 항체
1285 define / 의미를 정의하다
1286 particle / 입자
1287 pupil / 학생
1288 preach / 설교하다, 전도하다
1289 chronological / 발생(시간) 순서대로 된
1290 underprivileged / (사회·경제적으로) 혜택을 받지 못하는
1291 uncover / (비밀 등을) 알아내다, 폭로하다
1292 dump / 버리다, 쏟아 버리다
1293 acid / 산성의
1294 literary / 문학의
1295 border / 접경하다
1296 articulate / 분명히 표현하다(설명하다)
1297 alley / 골목
1298 mitigation / 완화, 경감
1299 vicious / 나쁜, 악덕의

1300–1319

1300 abound / 아주 많다, 풍부하다
1301 entitle / 자격을 주다
1302 asset / 자산, 재산
1303 underway / 진행 중인
1304 litter / 쓰레기
1305 mature / 성숙(발달)하다
1306 originate / 비롯되다, 유래하다
1307 tyranny / 독재(전체) 정치
1308 passage / 복도, 통로
1309 persist / 지속하다
1310 clog / 막(히)다
1311 hypothesis / 가설, 가정
1312 plain / 보통의, 평범한
1313 bizarre / 기이한, 특이한
1314 bleed / 피를 흘리다, 출혈하다
1315 smooth / 매끈한
1316 via / ~을 통해서, ~에 의해서
1317 combat / 전투, 싸움
1318 temporary / 일시적인, 임시의
1319 tremendous / 엄청난, 굉장한

1320–1339

1320 posterity / 후세, 후대
1321 cast / (의심을) 불러일으키다
1322 counteract / 대응[대항]하다, 상쇄[중화]하다
1323 contagious / 전염되는, 전염성의
1324 appointment / 임명, 지명
1325 assemble / 모으다, 집합시키다
1326 bilingual / 2개 국어를 말하는
1327 customized / 개개인의 요구에 맞춘
1328 govern / 좌우하다, 결정하다
1329 preponderance / (수적·양적으로) 우세함
1330 surround / 둘러싸다, 에워싸다
1331 conceive / 생각[상상]하다
1332 argument / 논쟁, 언쟁
1333 precede / ~에 앞서다, 선행하다
1334 signify / 의미하다, 나타내다
1335 transfer / 옮기다, 이동하다
1336 pigment / 색소, 안료
1337 cuisine / 요리(법)
1338 mobilize / (사람·물자·수단 등을) 동원하다
1339 subsequent / 그 후의, 다음의

1340–1450

1340 starvation / 굶주림, 기아
1341 urgent / 긴급한, 다급한
1342 respectively / 각각, 제각기
1343 deed / 행위, 행동
1344 fate / 운명
1345 philosophy / 철학
1346 bypass / 우회로, 건너뛰다, 우회하다
1347 attest / 증언하다, 입증하다
1348 bloom / 꽃이 피다, 꽃을 피우다
1349 boost / 신장시키다, 북돋우다
1350 deduct / 공제하다, 감하다

1351–1373

1351 avid / 열망하는, 열심인
1352 discrimination / 차별
1353 disguise / 변장(위장)하다
1354 cumulative / 누적되는, 누계의
1355 split / 쪼개다, 나누다
1356 pope / 교황
1357 droopy / 축 늘어진
1358 hierarchy / 계급, 계층, 서열
1359 migrate / 이주(이동)하다
1360 substantial / (양, 크기가) 상당한
1361 grave / 심각한, 중대한
1362 disciple / 제자, 신봉자
1363 prevail / 이기다, 압도하다
1364 revive / 소생하다, 부활시키다
1365 delude / 착각하게 하다, 속이다
1366 drawback / 결점, 문제점
1367 standardize / 표준화하다, 통일시키다
1368 dusk / 황혼, 어스름
1369 territory / 영역, 분야
1370 eligible / 자격이 있는
1371 vanish / 사라지다
1372 violence / 폭행, 폭력
1373 abuse / 학대하다

1374–1395

1374 choke / (성장을) 방해하다
1375 concise / 간결한
1376 deliberate / 숙고하다, 신중히 생각하다
1377 curse / 저주, 악담
1378 crush / 으스러뜨리다, 뭉개다
1379 niche / 딱 맞는 위치[지위], 적소
1380 intervention / 간섭
1381 mute / 말 없는, 무언의
1382 tissue / (세포들로 이뤄진) 조직
1383 personnel / 인원, 직원
1384 prejudice / 편견
1385 probe / 탐색[조사]하다
1386 clarity / 명료성, 명확성
1387 scope / 기회, 여지
1388 spatial / 공간의, 공간적인
1389 steep / 가파른, 비탈진
1390 temporal / 시간의
1391 patch / (행정 등으로) 땜대다, 때우다
1392 dismantle / 분해하다, 해체하다
1393 epoch / 시대, 시기
1394 exert / (힘, 영향력을) 가하다, 행사하다
1395 accommodate / 숙박시키다, 수용하다

1396–1417

1396 marital / 결혼(생활)의, 부부의
1397 affection / 애착, 애정
1398 extensive / 넓은, 광범위한
1399 aspiration / 열망, 포부
1400 cite / 언급하다
1401 universal / 일반[보편]적인
1402 proximity / 가까움, 근접
1403 prelude / 전조, 서막
1404 kinship / 친족(임), 친족 관계
1405 harassment / 괴롭힘
1406 repertoire / 레퍼토리, 연주 목록
1407 retailer / 소매상, 소매업, 소매 상점
1408 drift / (목적이나 목표 없이) 흘러가다, 방황하다
1409 dub / 재녹음(더빙)하다
1410 alongside / ~ 옆에, 나란히
1411 enact / 상연[연기]하다
1412 accidental / 우연한, 돌발적인
1413 encyclopedia / 백과사전
1414 endow / ~에게 (특질 등을) 부여하다
1415 associate / 연상하다, 연관 짓다
1416 feminine / 여성의, 여성스러운
1417 foe / 적

1418–1439

1418 revise / 변경[수정]하다
1419 exterminate / 근절하다, 몰살하다, 박멸하다
1420 amend / 개정[수정]하다
1421 coherent / 일관성 있는, 논리적인
1422 botanical / 식물(학)의
1423 indispensable / 없어서는 안 될, 필수적인
1424 abstain / 자제하다, 삼가다
1425 shortcoming / 결점, 단점
1426 residue / 잔여물
1427 displace / (밀어내고) 대신[대체]하다
1428 collide / 충돌[상충]하다, 부딪히다
1429 dreary / 음울한, 따분한
1430 sensitivity / 예민함, 민감함
1431 gravitational / 중력[인력]의
1432 ancestral / 조상의
1433 elevation / 고도, 해발
1434 elated / 의기양양한, 매우 기뻐하는
1435 nomadic / 유목의
1436 approximately / 거의, 대략
1437 enlighten / 계몽하다, 깨우치게 하다
1438 fluctuate / 변동하다, 오르내리다
1439 factual / 사실의, 실제의

1440–1450

1440 fraction / 부분, 일부
1441 frenzy / 광분, 광란
1442 orientation / 방향, 지향
1443 spherical / 구 모양의, 구체의
1444 grin / (이를 드러내고) 활짝 웃다
1445 growl / 으르렁거리다
1446 haunt / (유령 등이) 출몰하다
1447 overestimate / 과대평가하다
1448 resentment / 분함, 분노
1449 heap / 더미, 무더기
1450 tuition / 수업료
`;

/** =========================
 *  2) 정밀 해설(수동) — “단어별로” 아주 구체적으로
 *  ========================= */
const ETYMO_STRONG = {
  "patch": [
    ["어원/기원", "중세 영어(14세기쯤) pacche: ‘기워 붙이는 천 조각(패치)’에서 시작 → ‘구멍을 메우는 조각’ 이미지가 핵심."],
    ["뜻이 만들어진 흐름", "① ‘구멍 난 곳을 덮는 조각’(명사) → ② ‘그 조각을 붙여서 수선하다’(동사: 땜질/때우다) → ③ ‘임시로 고치다/수정하다’ → ④ 컴퓨터에서도 버그를 임시로 막는 수정 = software patch"],
    ["중2 암기 팁", "patch = ‘붙여서 막기’. 옷 구멍에 패치 붙이듯이, 문제점/허점도 ‘패치로 막는다’고 생각하면 절대 안 헷갈림."]
  ],
  "deduct": [
    ["어원/구성", "de-(떼어 내리다) + duct(이끌다)"],
    ["뜻이 만들어진 흐름", "전체 금액에서 어떤 부분을 ‘끌어내려서 빼는 것’ → 공제하다/감하다"],
    ["중2 암기 팁", "duct=길/통로 느낌(도관). de-가 붙으면 ‘아래로 빼낸다’ → 점수가 빠짐(공제)."]
  ],
  "subsequent": [
    ["어원/구성", "sub-(뒤/아래) + sequ(따르다)"],
    ["뜻이 만들어진 흐름", "어떤 일 ‘뒤를 따라오는 것’ → 그 후의/다음의"],
    ["중2 암기 팁", "sequence(순서)=따라오는 줄. subsequent=그 줄에서 ‘뒤에 오는 것’."]
  ],
  "chronological": [
    ["어원/구성", "chrono-(시간) + -logical(관련/논리적인 배열)"],
    ["뜻이 만들어진 흐름", "시간을 기준으로 배열됨 → 시간순의"],
    ["중2 암기 팁", "chrono=시간. 크로노(시간) + 순서 = 시간순."]
  ],
  "credibility": [
    ["어원/구성", "cred-(믿다) + -ible(가능) + -ity(성질)"],
    ["뜻이 만들어진 흐름", "‘믿을 수 있는 정도’라는 성질 → 신뢰성"],
    ["중2 암기 팁", "credit(신용)과 같은 뿌리. 신용=믿음=cred."]
  ],
  "auditory": [
    ["어원/구성", "aud-(듣다) + -ory(~의)"],
    ["뜻이 만들어진 흐름", "듣는 것과 관련 → 청각의"],
    ["중2 암기 팁", "audio=오디오=소리. aud- 보면 ‘듣다’부터 떠올리기."]
  ],
  "exclusive": [
    ["어원/구성", "ex-(밖) + clud(닫다/막다) + -ive"],
    ["뜻이 만들어진 흐름", "밖으로 ‘닫아서’ 못 들어오게 함 → 배타적인/독점적인"],
    ["중2 암기 팁", "include(포함) ↔ exclude(제외). ‘clude=닫다’로 기억."]
  ],
  "prospect": [
    ["어원/구성", "pro-(앞) + spect(보다)"],
    ["뜻이 만들어진 흐름", "앞을 내다봄 → 전망/가능성"],
    ["중2 암기 팁", "spectator(관객)=보는 사람. prospect=앞을 보는 것(전망)."]
  ]
};

/** =========================
 *  3) 자동 해설(강화)
 *  ========================= */
const PREFIX = [
  ["anti", "반대"], ["auto","스스로"], ["bi","2"], ["co","함께"], ["con","함께/완전히"],
  ["counter","반대/상쇄"], ["de","떼어/아래로/없애다"], ["dis","떼어/반대/없애다"],
  ["en","~하게 하다/넣다"], ["ex","밖으로/전-"], ["im","안으로/강화(또는 in- 변형)"],
  ["in","안/부정(아니다)"], ["inter","사이에/서로"], ["mis","잘못"], ["non","아님"],
  ["over","과하게"], ["pre","앞/미리"], ["pro","앞/찬성"], ["re","다시/뒤로"],
  ["sub","아래/뒤"], ["trans","가로질러/건너"]
];

const SUFFIX = [
  ["tion","명사(~하는 것/과정/결과)"], ["sion","명사(~하는 것/과정/결과)"], ["ment","명사(행동/결과)"],
  ["ity","명사(성질/상태)"], ["ness","명사(상태)"], ["ive","형용사(~한 성질의)"],
  ["al","형용사(~의)"], ["ic","형용사(~의)"], ["ous","형용사(~한)"],
  ["ly","부사(~하게)"], ["able","형용사(~할 수 있는)"], ["ible","형용사(~할 수 있는)"],
  ["ize","동사(~화하다)"], ["ify","동사(~하게 하다)"], ["ence","명사(상태/성질)"], ["ance","명사(상태/성질)"],
  ["ary","형용사(~의)"], ["ent","형용사/명사(~하는/한)"], ["ant","형용사/명사(~하는/한)"]
];

const ROOTS = [
  ["spect", "보다"], ["vid", "보다"], ["vis", "보다"],
  ["cred", "믿다"], ["fid", "믿다"], ["aud", "듣다"],
  ["dict", "말하다"], ["log", "말/이성/학문"], ["chron", "시간"],
  ["scrib", "쓰다"], ["script", "쓰다"], ["graph", "쓰다/기록"],
  ["port", "나르다/옮기다"], ["fer", "옮기다/나르다"], ["lat", "옮기다"],
  ["mit", "보내다"], ["miss", "보내다"], ["duc", "이끌다"], ["duct", "이끌다"],
  ["tract", "끌다"], ["press", "누르다"], ["puls", "치다/밀다"],
  ["tact", "만지다"], ["ten", "잡다/붙들다"], ["tain", "잡다/유지하다"],
  ["ced", "가다"], ["ceed", "가다"], ["gress", "걷다/가다"],
  ["form", "형태"], ["struct", "쌓다/세우다"], ["stit", "세우다"],
  ["mob", "움직이다"], ["mot", "움직이다"], ["viv", "살다"], ["vit", "살다"],
  ["gen", "태어나다/생기다"], ["nat", "태어나다/본성"],
  ["terr", "땅/영역"], ["bio", "생명"], ["astro", "별"], ["botan", "식물"],
  ["grav", "무겁다/중력"], ["mut", "바꾸다"], ["flu", "흐르다"],
  ["clar", "맑다/분명"], ["sens", "느끼다"], ["spir", "숨쉬다/정신"],
  ["cid", "죽이다/떨어지다"], ["rupt", "깨지다"], ["fract", "부수다/깨지다"]
];

function normalizeWord(w){ return String(w||"").toLowerCase().trim(); }

function detectPrefix(w){
  for (const [p, mean] of PREFIX) {
    if (w.startsWith(p) && w.length > p.length + 2) return [p, mean];
  }
  return null;
}
function detectSuffix(w){
  for (const [s, mean] of SUFFIX) {
    if (w.endsWith(s) && w.length > s.length + 2) return [s, mean];
  }
  return null;
}
function detectRoots(w){
  const found = [];
  const sorted = [...ROOTS].sort((a,b)=>b[0].length - a[0].length);
  for (const [r, mean] of sorted) {
    if (w.includes(r) && w.length > r.length + 1) {
      found.push([r, mean]);
      if (found.length >= 2) break;
    }
  }
  return found;
}
function inferPos(meaningKo){
  const m = String(meaningKo||"");
  if (m.includes("하다") || m.includes("되다")) return "동사";
  if (m.includes("적인") || m.endsWith("의")) return "형용사";
  if (m.includes("하게")) return "부사";
  return "어휘";
}

function buildMeaningChain(pre, roots, suf){
  const steps = [];
  if (pre) steps.push(`① ${pre[0]} = “${pre[1]}”`);
  if (roots.length) {
    roots.forEach((r, i) => steps.push(`${pre ? (i===0 ? "②" : "③") : (i===0 ? "①":"②")} ${r[0]} = “${r[1]}”`));
  }
  if (suf) steps.push(`마지막: -${suf[0]} = “${suf[1]}”`);
  if (!steps.length) steps.push("① (분해 단서 약함) → ‘핵심 장면’으로 연결");
  return steps.join(" → ");
}
function buildMnemonic(word, pre, roots, suf, pos){
  const chunk = [];
  if (pre) chunk.push(`${pre[0]}(${pre[1]})`);
  if (roots.length) chunk.push(...roots.map(r=>`${r[0]}(${r[1]})`));
  if (suf) chunk.push(`-${suf[0]}(${suf[1]})`);
  if (chunk.length) return `암기 공식: ${word} ≈ ${chunk.join(" + ")} (품사: ${pos})`;
  return `암기 팁: ${word}는 “장면 1개”로 고정 (품사: ${pos})`;
}
function buildAntiConfusion(word, pre, suf){
  const tips = [];
  if (pre && pre[0] === "re") tips.push("re- = 다시/뒤로 (반대 아님)");
  if (pre && pre[0] === "dis") tips.push("dis- = 분리/제거/반대 (in- 부정과 구분)");
  if (pre && pre[0] === "inter") tips.push("inter- = 사이에 끼기 (돕다가 아니라 간섭 이미지)");
  if (suf && suf[0] === "tion") tips.push("-tion = 명사(과정/결과)");
  if (suf && suf[0] === "ity") tips.push("-ity = ~성/상태");
  if (word.endsWith("ly")) tips.push("-ly = 부사(~하게)");
  if (!tips.length) tips.push("오답 방지: 핵심 이미지 1개만 고정");
  return tips.join(" / ");
}

function autoEtymo(word, meaningKo){
  const w = normalizeWord(word);
  const pre = detectPrefix(w);
  const suf = detectSuffix(w);
  const roots = detectRoots(w);
  const pos = inferPos(meaningKo);

  const breakdown = [];
  if (pre) breakdown.push(`${pre[0]}- (${pre[1]})`);
  if (roots.length) breakdown.push(...roots.map(r => `${r[0]} (${r[1]})`));
  if (suf) breakdown.push(`-${suf[0]} (${suf[1]})`);
  if (!breakdown.length) breakdown.push(`${w} (분해 단서 약함)`);

  const chain = buildMeaningChain(pre, roots, suf);
  const mnemonic = buildMnemonic(w, pre, roots, suf, pos);
  const anti = buildAntiConfusion(w, pre, suf);

  const reason = (() => {
    if (pre || suf || roots.length) {
      const core = roots.length ? roots.map(r=>r[1]).join(" + ") : "핵심 의미";
      const dir = pre ? `“${pre[1]}” 방향 +` : "";
      const tail = suf ? ` + “${suf[1]}”` : "";
      return `${dir} ${core}${tail} 로 뜻이 자연스럽게 만들어집니다.`;
    }
    return `분해보다 “장면”으로 외우는 편이 빠릅니다: ${w}의 대표 장면을 하나 정해 뜻을 고정하세요.`;
  })();

  return [
    ["어원/구성(자동·개별)", breakdown.join(" + ")],
    ["뜻이 만들어진 흐름(자동·개별)", chain],
    ["왜 이런 뜻이 되나(자동·개별)", reason],
    ["중2 암기 공식(자동·개별)", mnemonic],
    ["오답 방지 포인트(자동·개별)", anti]
  ];
}

function getEtymoCard(word, meaningKo) {
  const key = normalizeWord(word);
  const strong = ETYMO_STRONG[key];
  if (strong) return strong;
  return autoEtymo(key, meaningKo);
}

/** =========================
 *  4) 파싱: "번호 단어 / 뜻"
 *  ========================= */
function parseEntries(raw) {
  const lines = raw.split(/\r?\n/);
  const out = [];
  const re = /^\s*(\d{4})\s+([A-Za-z-]+)\s*\/\s*(.+?)\s*$/;
  for (const line of lines) {
    const m = line.match(re);
    if (!m) continue;
    const num = parseInt(m[1], 10);
    const word = m[2].trim();
    const meaning = m[3].trim();
    out.push({ num, word, meaning });
  }
  return out;
}
const ALL = parseEntries(RAW);

/** =========================
 *  5) 유사 오답 생성
 *  ========================= */
function pickDistractors(correctMeaning, poolMeanings, count=3) {
  const len = correctMeaning.length;
  const similar = poolMeanings.filter(m => m !== correctMeaning && Math.abs(m.length - len) <= 6);

  const picked = new Set();
  function takeFrom(arr) {
    const shuffled = shuffle([...arr]);
    for (const x of shuffled) {
      if (picked.size >= count) break;
      if (x === correctMeaning) continue;
      picked.add(x);
    }
  }
  takeFrom(similar);
  if (picked.size < count) takeFrom(poolMeanings);
  return [...picked].slice(0, count);
}

function buildQuestions(entries) {
  const meanings = entries.map(e => e.meaning);
  return entries.map(e => {
    const correct = e.meaning;
    const distractors = pickDistractors(correct, meanings, 3);
    const options = shuffle([correct, ...distractors]);
    const correctIndex = options.indexOf(correct);
    return { num: e.num, word: e.word, meaning: e.meaning, correct, options, correctIndex };
  });
}

/** =========================
 *  6) 상태/저장
 *  ========================= */
const dom = {
  pillCount: document.getElementById("pillCount"),
  pillProgress: document.getElementById("pillProgress"),
  pillScore: document.getElementById("pillScore"),
  bar: document.getElementById("bar"),
  qbox: document.getElementById("qbox"),
  summary: document.getElementById("summary"),
  rangeSelect: document.getElementById("rangeSelect"),
  shuffleToggle: document.getElementById("shuffleToggle"),
  saveToggle: document.getElementById("saveToggle"),
  btnStart: document.getElementById("btnStart"),
  btnWrongOnly: document.getElementById("btnWrongOnly"),
  btnReset: document.getElementById("btnReset"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
  btnCheck: document.getElementById("btnCheck"),
};

function getKey() {
  const range = dom.rangeSelect.value;
  return `vocab_quiz_1200_1450_etymo_${range}_v5_autocheck`;
}
function defaultState(total) {
  return {
    idx: 0,
    selected: Array(total).fill(null),
    checked: Array(total).fill(false),
    score: 0,
    wrong: [],
    order: [...Array(total).keys()]
  };
}
let quiz = { entries: [], questions: [], state: null };

function saveState() {
  if (!dom.saveToggle.checked) return;
  localStorage.setItem(getKey(), JSON.stringify(quiz.state));
}
function loadState(total) {
  if (!dom.saveToggle.checked) return null;
  try {
    const raw = localStorage.getItem(getKey());
    if (!raw) return null;
    const s = JSON.parse(raw);
    if (!s || !Array.isArray(s.selected) || s.selected.length !== total) return null;
    return s;
  } catch { return null; }
}
function filterByRange(rangeStr) {
  const [a,b] = rangeStr.split("-").map(x => parseInt(x,10));
  return ALL.filter(e => e.num >= a && e.num <= b);
}

/** =========================
 *  7) 렌더
 *  ========================= */
function render() {
  if (!quiz.state) {
    dom.qbox.innerHTML = `<div class="small muted">상단에서 범위를 선택하고 “퀴즈 시작/재시작”을 누르세요.</div>`;
    dom.pillCount.textContent = `문항: 0`;
    dom.pillProgress.textContent = `진행: 0/0`;
    dom.pillScore.textContent = `점수: 0`;
    dom.bar.style.width = "0%";
    dom.btnPrev.disabled = true;
    dom.btnNext.disabled = true;
    dom.btnCheck.disabled = true;
    dom.btnWrongOnly.disabled = true;
    dom.summary.innerHTML = "";
    return;
  }

  const total = quiz.questions.length;
  const s = quiz.state;
  const done = s.checked.filter(Boolean).length;

  dom.pillCount.textContent = `문항: ${total}`;
  dom.pillProgress.textContent = `진행: ${done}/${total}`;
  dom.pillScore.textContent = `점수: ${s.score}`;
  dom.bar.style.width = `${Math.round((done/total)*100)}%`;

  dom.btnPrev.disabled = s.idx === 0;
  dom.btnNext.disabled = s.idx === total - 1;

  const qIndex = s.order[s.idx];
  const q = quiz.questions[qIndex];

  const chosen = s.selected[s.idx];
  const checked = s.checked[s.idx];

  // ✅ 자동 채점이므로 정답확인 버튼은 "사용 불가"로 처리(그래도 UI는 남겨둠)
  dom.btnCheck.disabled = true;

  dom.qbox.innerHTML = `
    <div class="qhead">
      <div class="qnum">Q${s.idx+1} / ${total} <span class="meta">(단어번호 ${q.num})</span></div>
      <div class="word">${escapeHtml(q.word)}</div>
    </div>
    <div class="choices" id="choices"></div>
    <div id="resultArea"></div>
  `;

  const choicesEl = document.getElementById("choices");
  q.options.forEach((text, idx0) => {
    let cls = "choice";
    if (chosen === idx0) cls += " selected";
    if (checked) {
      if (idx0 === q.correctIndex) cls += " correct";
      else if (chosen === idx0 && chosen !== q.correctIndex) cls += " wrong";
    }
    const el = document.createElement("div");
    el.className = cls;
    el.innerHTML = `<div class="tag">${idx0+1}</div><div>${escapeHtml(text)}</div>`;
    el.addEventListener("click", () => {
      if (s.checked[s.idx]) return; // 이미 채점된 문제면 변경 불가
      s.selected[s.idx] = idx0;
      // ✅ 선택 즉시 채점(=정답확인 버튼 누른 효과)
      checkAnswer();
    });
    choicesEl.appendChild(el);
  });

  const resultArea = document.getElementById("resultArea");

  if (checked) {
    const ok = chosen === q.correctIndex;

    let etymoHtml = "";
    if (!ok) {
      const card = getEtymoCard(q.word, q.meaning);
      const safeCard = (Array.isArray(card) && card.length)
        ? card
        : [
            ["어원/구성(기본)", "이 단어는 ‘핵심 이미지’로 외우는 게 좋습니다."],
            ["뜻이 만들어진 흐름(기본)", "이미지 → 문맥 → 뜻 연결 순서로 기억하세요."],
            ["중2 암기 팁(기본)", "오늘은 ‘그림 1개’만 고정해도 오답이 줄어요."]
          ];

      etymoHtml = `
        <div class="etymo">
          <div class="title">오답 감소 해설 (어원/의미 생성/암기)</div>
          <div class="small muted">
            단어: <span class="kbd">${escapeHtml(q.word)}</span>
            <span style="margin-left:8px;">(해설 항목: ${safeCard.length}개)</span>
          </div>
          <ul class="small">
            ${safeCard.map(([k,v]) => `<li><b>${escapeHtml(k)}</b>: ${escapeHtml(v)}</li>`).join("")}
          </ul>
        </div>
      `;
    }

    resultArea.innerHTML = `
      <div class="result ${ok ? "good" : "bad"}">
        <div><b>${ok ? "정답!" : "오답"}</b></div>
        <div class="small">
          정답: <b>${q.correctIndex+1}</b> (${escapeHtml(q.options[q.correctIndex])})<br/>
          선택: <b>${chosen+1}</b> (${escapeHtml(q.options[chosen])})
        </div>
      </div>
      ${etymoHtml}
    `;
  } else {
    resultArea.innerHTML = `<div class="small muted" style="margin-top:10px;">보기를 누르면 즉시 채점됩니다.</div>`;
  }

  if (done === total) renderSummary();
  else dom.summary.innerHTML = "";

  dom.btnWrongOnly.disabled = (done === 0);
}

function renderSummary() {
  const total = quiz.questions.length;
  const s = quiz.state;
  const wrongOnly = s.wrong;

  dom.summary.innerHTML = `
    <div class="hr"></div>
    <div class="row">
      <div>
        <div style="font-weight:900; font-size:16px;">결과</div>
        <div class="small">총점: <b>${s.score}</b> / ${total}</div>
        <div class="small muted">완료: ${total}문항</div>
      </div>
      <div class="row">
        <button class="btn secondary" id="btnGoFirst">첫 문제로</button>
      </div>
    </div>

    <details ${wrongOnly.length ? "open" : ""}>
      <summary>오답 노트 (${wrongOnly.length}개)</summary>
      ${wrongOnly.length ? `
      <table>
        <thead>
          <tr><th>Q</th><th>단어</th><th>내 선택</th><th>정답</th></tr>
        </thead>
        <tbody>
          ${wrongOnly.map(w => `
            <tr>
              <td>${w.qNo}</td>
              <td><b>${escapeHtml(w.word)}</b></td>
              <td>${escapeHtml(w.chosenText)}</td>
              <td>${escapeHtml(w.correctText)}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>` : `<div class="small muted" style="margin-top:10px;">오답이 없습니다.</div>`}
    </details>
  `;

  document.getElementById("btnGoFirst").addEventListener("click", () => {
    quiz.state.idx = 0;
    saveState();
    render();
  });
}

function checkAnswer() {
  const s = quiz.state;
  const qIndex = s.order[s.idx];
  const q = quiz.questions[qIndex];

  const chosen = s.selected[s.idx];
  if (chosen === null || s.checked[s.idx]) return;

  s.checked[s.idx] = true;
  if (chosen === q.correctIndex) {
    s.score += 1;
  } else {
    const qNo = s.idx + 1;
    const exists = s.wrong.some(x => x.qNo === qNo);
    if (!exists) {
      s.wrong.push({
        qNo,
        word: q.word,
        chosenText: q.options[chosen],
        correctText: q.options[q.correctIndex],
      });
    }
  }
  saveState();
  render();
}

function startQuiz({ wrongOnly=false } = {}) {
  const range = dom.rangeSelect.value;
  const entries = filterByRange(range);
  const questions = buildQuestions(entries);

  const total = questions.length;
  const baseState = defaultState(total);
  if (dom.shuffleToggle.checked) baseState.order = shuffle(baseState.order);

  const loaded = loadState(total);

  quiz.entries = entries;
  quiz.questions = questions;
  quiz.state = loaded ?? baseState;

  if (wrongOnly && loaded?.wrong?.length) {
    const wrongWords = new Set(loaded.wrong.map(w => w.word.toLowerCase()));
    const wrongEntries = entries.filter(e => wrongWords.has(e.word.toLowerCase()));
    if (wrongEntries.length) {
      quiz.entries = wrongEntries;
      quiz.questions = buildQuestions(wrongEntries);
      quiz.state = defaultState(quiz.questions.length);
      if (dom.shuffleToggle.checked) quiz.state.order = shuffle(quiz.state.order);
    }
  }

  saveState();
  render();
}

/** ===== 유틸 ===== */
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

/** ===== 이벤트 ===== */
dom.btnStart.addEventListener("click", () => startQuiz({ wrongOnly:false }));
dom.btnWrongOnly.addEventListener("click", () => startQuiz({ wrongOnly:true }));

dom.btnReset.addEventListener("click", () => {
  if (!confirm("선택한 범위의 저장된 진행상황을 완전 초기화할까요?")) return;
  localStorage.removeItem(getKey());
  quiz.state = null;
  render();
});

dom.btnPrev.addEventListener("click", () => {
  if (!quiz.state) return;
  quiz.state.idx = Math.max(0, quiz.state.idx - 1);
  saveState();
  render();
});
dom.btnNext.addEventListener("click", () => {
  if (!quiz.state) return;
  quiz.state.idx = Math.min(quiz.questions.length - 1, quiz.state.idx + 1);
  saveState();
  render();
});

// ✅ 버튼 눌러도 동일하게 채점되긴 하지만(보험), 자동 채점이 기본이라 거의 안 씀
dom.btnCheck.addEventListener("click", checkAnswer);

dom.rangeSelect.addEventListener("change", () => {
  quiz.state = null;
  render();
});

dom.saveToggle.addEventListener("change", () => {
  if (!dom.saveToggle.checked) {
    alert("자동 저장이 꺼졌습니다. 새로고침하면 진행상황이 유지되지 않을 수 있어요.");
  }
});

render();

/** =========================
 *  ✅ PWA Service Worker 등록
 *  ========================= */
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("./sw.js").catch(console.error);
  });
}
</script>
</body>
</html>
